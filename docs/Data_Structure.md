## Структура данных News Agent

Этот документ описывает структуру базы данных и основные сущности, с которыми работает News Agent.

По умолчанию используется SQLite‑база `data/news_agent.db`, но конфигурация позволяет подключать PostgreSQL, MySQL и другие движки через `DATABASE_URL`.

---

## Общая схема

Основные таблицы:
- `news_articles` – новости (статьи).
- `search_history` – история поисковых запросов.
- `rss_feeds` – (зарезервировано) справочник RSS‑каналов.
- `system_settings` – системные и поисковые настройки.

Связи:
- один `search_history` ко многим `news_articles` (через `search_history_id`);
- `system_settings` независима, используется для конфигурации поведения системы.

---

## Таблица `news_articles`

Хранит все собранные статьи (включая дубликаты и нерелевантные).

Основные поля:
- **`id`** *(PK, integer)* – уникальный идентификатор статьи.
- **`title`** *(text)* – заголовок.
- **`content`** *(text)* – содержимое статьи (часто HTML, summary/description из RSS).
- **`link`** *(text)* – URL на оригинальную статью.
- **`source`** *(text)* – название источника / RSS‑канала.
- **`published_at`** *(datetime, nullable)* – дата публикации (если есть в RSS).
- **`collected_at`** *(datetime)* – дата/время добавления записи системой.

Поля, связанные с историей запроса:
- **`search_history_id`** *(FK → `search_history.id`)* – запрос, в рамках которого статья была собрана.

Поля, связанные с дедупликацией:
- **`is_duplicate`** *(boolean, default False)* – флаг, является ли статья дубликатом.
- **`duplicate_of`** *(integer, nullable)* – `id` оригинальной статьи, если текущая помечена как дубликат.
- **`content_hash`** *(text)* – SHA256‑хеш содержимого (для быстрой проверки точных дубликатов).

Поля, связанные с классификацией:
- **`relevance_score`** *(float, 0.0–1.0, nullable)* – числовая оценка релевантности.
- **`is_relevant`** *(boolean, nullable)* – флаг релевантности (на основе порогового значения).
- **`classification_reason`** *(text, nullable)* – текстовое объяснение/обоснование решения LLM.

Поля, связанные с пост‑обработкой:
- **`summary`** *(text, nullable)* – краткое саммари статьи (для релевантных статей).
- **`embedding`** *(JSON / text, nullable)* – векторное представление статьи:
  - обычно массив чисел (float) фиксированной длины (например, 1536);
  - используется для семантического поиска.

Ограничения и индексы:
- **уникальный индекс** на пару (`link`, `search_history_id`):
  - одна и та же ссылка может появляться в разных поисках, но только один раз в рамках одного `search_history_id`.
- Индекс по `content_hash` для ускорения дедупликации.

---

## Таблица `search_history`

Хранит отдельные «запуски» поиска/обработки.

Основные поля:
- **`id`** *(PK, integer)* – уникальный идентификатор запуска.
- **`created_at`** *(datetime)* – время создания записи/старта обработки.

Параметры запроса:
- **`rss_feeds`** *(text)* – список RSS‑каналов (каждый с новой строки).
- **`selection_criteria`** *(text)* – текстовый критерий отбора новостей.
- **`llm_model`** *(text)* – модель LLM, использованная при классификации.
- **`llm_temperature`** *(float)* – температура генерации.
- **`similarity_threshold`** *(float)* – порог схожести для дедупликации.
- **`openai_api_base`** *(text, nullable)* – API‑endpoint, использованный для запуска (если отличен от стандартного).

Результирующая статистика:
- **`results_data`** *(JSON / text)* – агрегированная информация по запуску, например:
  - `total` – общее количество статей;
  - `relevant` – количество релевантных;
  - `duplicates` – количество дубликатов;
  - `unique_non_relevant` – количество уникальных нерелевантных;
  - `collected_articles` – количество собранных статей;
  - `processed_articles` – количество успешно обработанных статей;
  - дополнительные метаданные.

Связи:
- отношение «один ко многим» с `news_articles`:
  - `search_history.articles` – коллекция связанных статей;
  - `news_articles.search_history` – ссылка на родительский запуск.

Каскадное поведение:
- при удалении записи `search_history`:
  - все связанные статьи удаляются каскадно;
  - используется для очистки отдельных запусков или всей базы.

---

## Таблица `rss_feeds`

На момент описания — **зарезервирована для будущего использования**.

Планируется:
- хранить список RSS‑каналов в БД вместо/в дополнение к `.env`;
- управлять каналами через UI (добавление/удаление/редактирование);
- использовать этот справочник как источник каналов для запусков поиска.

Пример возможной структуры:
- `id` *(PK)* – идентификатор записи;
- `url` *(text)* – URL RSS‑ленты;
- `title` *(text, nullable)* – человекочитаемое название;
- `enabled` *(boolean)* – флаг активности;
- `created_at` / `updated_at` *(datetime)* – временные метки.

---

## Таблица `system_settings`

Используется для хранения динамических настроек, которые можно менять через веб‑интерфейс без перезапуска приложения.

Основные поля:
- **`id`** *(PK, integer)* – уникальный идентификатор.
- **`key`** *(text, unique, indexed)* – ключ настройки (строковый идентификатор).
- **`value`** *(text)* – значение настройки (все значения хранятся как текст, приводятся к нужному типу в коде).
- **`description`** *(text, nullable)* – человекочитаемое описание.
- **`category`** *(text, nullable)* – категория (например, `semantic_search`, `keyword_matching` и т.п.).
- **`updated_at`** *(datetime)* – дата/время последнего изменения.

### Настройки семантического поиска

Типичные ключи:
- `semantic_threshold_1_word` – порог для запросов из 1 слова (по умолчанию 0.25).
- `semantic_threshold_2_words` – порог для запросов из 2 слов (0.3).
- `semantic_threshold_3_words` – порог для запросов из 3 слов (0.35).
- `semantic_threshold_4_5_words` – порог для запросов из 4–5 слов (0.4).
- `semantic_threshold_6_plus_words` – порог для запросов из 6+ слов (0.5).

### Настройки keyword‑matching

Типичные ключи:
- `keyword_match_min_ratio` – минимальный процент совпадения слов для учёта keyword‑совпадения (например, 0.5).
- `keyword_boost_weight` – вес буста, добавляемого к similarity для статей с keyword‑совпадениями (например, 0.1).
- `keyword_match_min_score` – минимальный общий score для включения статьи по keyword‑matching (например, 0.3).

Особенности:
- Настройки инициализируются при первом запуске с значениями по умолчанию.
- Изменения из веб‑интерфейса применяются сразу и сохраняются в БД.

---

## Работа с базой данных

### Инициализация и создание
- При первом запуске приложения:
  - создаются все таблицы, если они отсутствуют;
  - инициализируются записи в `system_settings` с дефолтными значениями.
- Для SQLite база создаётся в директории `data/`.

### Подключение
- Строка подключения задаётся через:
  - `DATABASE_URL=sqlite:///data/news_agent.db` (по умолчанию);
  - для PostgreSQL: `postgresql://user:password@host:port/dbname`;
  - для MySQL: `mysql://user:password@host:port/dbname`.

### ORM и транзакции
- Все операции выполняются через SQLAlchemy ORM:
  - модели определены в `models.py`;
  - используется сессионный паттерн (`session`).
- При ошибках записи:
  - выполняется `rollback`;
  - ошибка логируется;
  - система по возможности продолжает работу.

### Удаление и очистка
- Вкладка «История запросов» предоставляет:
  - удаление одного `search_history` (с каскадным удалением статей);
  - полную очистку БД (удаление всех записей).

---

## Взаимодействие модулей с данными

Краткий обзор, какие модули работают с какими сущностями:

- **`agents/rss_collector.py`**
  - читает `search_history` (параметры запроса);
  - добавляет записи в `news_articles`.

- **`agents/deduplicator.py`**
  - читает `news_articles` текущего запроса;
  - обновляет поля `is_duplicate`, `duplicate_of`, использует `content_hash`.

- **`agents/classifier.py`**
  - читает неклассифицированные и недубликатные статьи;
  - обновляет `relevance_score`, `is_relevant`, `classification_reason`.

- **`agents/summarizer.py`**
  - читает релевантные и недубликатные статьи;
  - обновляет `summary`.

- **`agents/embeddings.py`**
  - читает статьи (часто только `id`, `title`, `content`);
  - обновляет `embedding`;
  - читает `system_settings` для порогов и параметров поиска.

- **Flask‑приложение (`app.py`)**
  - читает/создаёт `search_history` при запуске обработки;
  - обновляет `results_data` по завершении;
  - читает данные для отображения в UI (таблицы статей, истории, статистика);
  - читает и обновляет `system_settings` по запросам из UI.

---

## Рекомендации по расширению данных

При добавлении новых полей/таблиц:
- Внести изменения в `models.py` и провести миграцию (рекомендуется использовать Alembic).
- Обновить:
  - соответствующие модули в `agents/`, которые читают/пишут данные;
  - UI (если новые поля должны отображаться).
- При изменении структуры таблиц, которые используются в семантическом поиске:
  - убедиться, что новый формат `embedding` совместим;
  - обновить код предобработки текста перед генерацией вектора.

Для продакшена рекомендуется:
- перейти на PostgreSQL или другой полнофункциональный движок;
- включить регулярные бэкапы БД;
- отслеживать рост размера `embedding`‑данных и при необходимости использовать отдельное хранилище или индекс (например, pgvector / специализированный векторный движок).

